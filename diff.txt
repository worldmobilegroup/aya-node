diff --git a/pallets/pallet-epoch/src/lib.rs b/pallets/pallet-epoch/src/lib.rs
index 1415cfd..62ae586 100644
--- a/pallets/pallet-epoch/src/lib.rs
+++ b/pallets/pallet-epoch/src/lib.rs
@@ -3,16 +3,16 @@ extern crate alloc;
 #[cfg_attr(feature = "std", macro_use)]
 extern crate serde;
 extern crate sp_std;
+use alloc::format;
 use alloc::{string::ToString, vec::Vec};
 use core::primitive::str;
-use log::info;
-pub use pallet::*;
-
 use frame_support::{
     dispatch::DispatchResult, pallet_prelude::*, storage::types::StorageMap,
     unsigned::TransactionSource, weights::Weight,
 };
 use frame_system::{offchain::*, pallet_prelude::*};
+use log::info;
+pub use pallet::*;
 use serde::{Deserialize, Deserializer, Serialize, Serializer};
 
 use sp_application_crypto::{AppCrypto, RuntimePublic};
@@ -297,83 +297,6 @@ pub mod pallet {
     }
 
     use alloc::format;
-    impl<T: Config> Pallet<T>
-    where
-        T: frame_system::offchain::SendTransactionTypes<Call<T>>,
-    {
-        fn create_inclusion_transaction() -> Result<(), &'static str> {
-            log::info!("Creating an inclusion transaction with an event payload");
-
-            // Create a unique nonce
-            let nonce: u64 = sp_io::offchain::timestamp().unix_millis();
-            let response = Self::fetch_all_events()?;
-
-            // Deserialize the events
-            let events: Vec<CustomEvent> = serde_json::from_slice(&response).map_err(|e| {
-                log::error!("Failed to deserialize events: {:?}", e);
-                <Error<T>>::JsonSerializationError
-            })?;
-
-            log::info!("Fetched events: {:?}", events);
-            // Fetch the latest event from the queue
-            let latest_event = {
-                // Fetch all events
-                // let events = Self::fetch_all_events().map_err(|e| {
-                //     log::error!("Error fetching events: {:?}", e);
-                //     "HttpFetchingError"
-                // })?;
-                // let events = Self::fetch_all_events();
-
-                // log::info!("Fetched events: {:?}", events);
-                // Check if there are any events to process
-                // if events.is_empty() {
-                //     log::info!("No events to process.");
-                //     return Err("No events in the queue");
-                // }
-
-                // Get the latest event
-                // events.last().ok_or("No events in the queue")?.clone()
-            };
-            // log::info!("Latest event before encoding: {:?}", latest_event.clone());
-
-            // Encode the latest event payload
-            // let payload_vec = latest_event.encode();
-            // Ensure the latest event is correctly encoded/decoded
-            // let encoded_event = serde_json::to_string(&latest_event).map_err(|e| {
-            //     log::error!("Error encoding event: {:?}", e);
-            //     "EncodingError"
-            // })?;
-            // log::info!("Encoded latest event: {}", encoded_event);
-            /////
-            // Simulate a larger payload with detailed event information
-            // let mut stub_event_data = Vec::new();
-            // for i in 0..100 {
-            //     stub_event_data.push(format!(
-            //         "{{\"event_id\":{},\"event_data\":\"data_{}\"}}",
-            //         i, i
-            //     ));
-            // }
-            // let payload_vec = stub_event_data.encode();
-            // log::info!("Encoded payload: {:?}", payload_vec);
-
-            // log::info!("Encoded payload: {:?}", stub_event_data);
-
-            // Create the call with the nonce and payload
-            // let call = Call::<T>::process_epoch_event {
-            //     nonce,
-            //     payload: encoded_event.clone().into(),
-            // };
-            // log::info!("Submitting call with payload: {:?}", encoded_event);
-
-            // // Submit the transaction
-            // match frame_system::offchain::SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into()) {
-            //     Ok(_) => log::info!("Stub event transaction submitted successfully"),
-            //     Err(e) => log::error!("Error submitting stub event transaction: {:?}", e),
-            // }
-
-            Ok(())
-        }
-    }
 
     impl<T: Config> Pallet<T>
     where
@@ -398,181 +321,6 @@ pub mod pallet {
         }
     }
 
-    impl<T: Config> Pallet<T> {
-        fn fetch_all_events() -> Result<Vec<u8>, Error<T>> {
-            // const HTTP_REMOTE_REQUEST: &str = "http://127.0.0.1:5555";
-            // const HTTP_HEADER_USER_AGENT: &str = "SubstrateOffchainWorker";
-            // const HTTP_HEADER_CONTENT_TYPE: &str = "Content-Type";
-            // const CONTENT_TYPE_JSON: &str = "application/json";
-            // const FETCH_TIMEOUT_PERIOD: u64 = 3000; // in milliseconds
-
-            // // Create the JSON-RPC request payload
-            // let json_payload = serde_json::json!({
-            //     "jsonrpc": "2.0",
-            //     "method": "list_all_events",
-            //     "params": [],
-            //     "id": 1
-            // })
-            // .to_string()
-            // .into_bytes();
-
-            // // Initiate an external HTTP POST request
-            // let request =
-            //     rt_offchain::http::Request::post(HTTP_REMOTE_REQUEST, vec![&json_payload])
-            //         .add_header("User-Agent", HTTP_HEADER_USER_AGENT)
-            //         .add_header(HTTP_HEADER_CONTENT_TYPE, CONTENT_TYPE_JSON)
-            //         .deadline(
-            //             sp_io::offchain::timestamp()
-            //                 .add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD)),
-            //         )
-            //         .send()
-            //         .map_err(|_| <Error<T>>::HttpFetchingError)?;
-
-            // let response = request
-            //     .try_wait(
-            //         sp_io::offchain::timestamp()
-            //             .add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD)),
-            //     )
-            //     .map_err(|_| <Error<T>>::HttpFetchingError)?
-            //     .map_err(|_| <Error<T>>::HttpFetchingError)?;
-
-            // if response.code != 200 {
-            //     log::error!("Non-200 response code: {}", response.code);
-            //     return Err(<Error<T>>::HttpFetchingError);
-            // }
-
-            // let response_body = response.body().collect::<Vec<u8>>();
-            // let json_string = String::from_utf8(response_body).map_err(|e| {
-            //     log::error!("Failed to parse response body as UTF-8: {:?}", e);
-            //     <Error<T>>::InvalidUtf8
-            // })?;
-
-            // log::info!("HTTP Response Body: {}", json_string); // Log the raw JSON response
-
-            // // First, parse the top-level JSON response
-            // let rpc_response: serde_json::Value = serde_json::from_str(&json_string).map_err(|e| {
-            //     log::error!("Failed to parse JSON-RPC response: {:?}", e);
-            //     <Error<T>>::InvalidResponseFormat
-            // })?;
-
-            // // Extract the "result" field which is a stringified JSON
-            // let result_str = rpc_response["result"].as_str().ok_or(<Error<T>>::InvalidResponseFormat)?;
-
-            // // Unescape the JSON string
-            // let unescaped_result_str = result_str.replace("\\\"", "\"").replace("\\\\", "\\");
-
-            // // Parse the unescaped JSON string to the actual result structure
-            // let inner_response: serde_json::Value = serde_json::from_str(&unescaped_result_str).map_err(|e| {
-            //     log::error!("Failed to parse inner JSON-RPC response: {:?}", e);
-            //     <Error<T>>::InvalidResponseFormat
-            // })?;
-
-            // // Extract the events array from the parsed inner response
-            // let events_value = inner_response["events"].as_array().ok_or(<Error<T>>::InvalidResponseFormat)?;
-
-            // // Convert the events to the expected structure
-            // let mut events: Vec<Vec<CustomEvent>> = Vec::new();
-            // for event_group in events_value.iter() {
-            //     let mut parsed_event_group = Vec::new();
-            //     for event_value in event_group.as_array().ok_or(<Error<T>>::InvalidResponseFormat)? {
-            //         let event_json_str = event_value["data"].as_str().ok_or(<Error<T>>::InvalidResponseFormat)?;
-            //         let nested_data: serde_json::Value = serde_json::from_str(event_json_str).map_err(|e| {
-            //             log::error!("Failed to parse nested data field: {:?}", e);
-            //             <Error<T>>::JsonSerializationError
-            //         })?;
-
-            //         // Reconstruct the CustomEvent
-            //         let event = CustomEvent {
-            //             id: event_value["id"].as_u64().unwrap_or_default(),
-            //             data: CustomData(BoundedVec::try_from(nested_data.to_string().into_bytes()).map_err(|_| <Error<T>>::JsonSerializationError)?),
-            //             timestamp: event_value["timestamp"].as_u64().unwrap_or_default(),
-            //             block_height: event_value["block_height"].as_u64().unwrap_or_default(),
-            //             last_epoch: nested_data["last_epoch"].as_u64().unwrap_or_default(),
-            //             last_blockhash: BoundedVec::try_from(nested_data["last_blockhash"].as_str().unwrap_or_default().as_bytes().to_vec()).map_err(|_| <Error<T>>::JsonSerializationError)?,
-            //             last_slot: nested_data["last_slot"].as_u64().unwrap_or_default(),
-            //             new_epoch: nested_data["new_epoch"].as_u64().unwrap_or_default(),
-            //             new_slot: nested_data["new_slot"].as_u64().unwrap_or_default(),
-            //             new_blockhash: BoundedVec::try_from(nested_data["new_blockhash"].as_str().unwrap_or_default().as_bytes().to_vec()).map_err(|_| <Error<T>>::JsonSerializationError)?,
-            //             epoch_nonce: BoundedVec::try_from(nested_data["epoch_nonce"].as_str().unwrap_or_default().as_bytes().to_vec()).map_err(|_| <Error<T>>::JsonSerializationError)?,
-            //             extra_entropy: nested_data["extra_entropy"].as_str().map(|s| BoundedVec::try_from(s.as_bytes().to_vec()).map_err(|_| <Error<T>>::JsonSerializationError)).transpose()?,
-            //         };
-
-            //         parsed_event_group.push(event);
-            //     }
-            //     events.push(parsed_event_group);
-            // }
-
-            // if events.is_empty() {
-            //     log::info!("No events to process.");
-            //     return Err(<Error<T>>::NoEventsInQueue);
-            // }
-
-            // let events_json = serde_json::to_string(&events).map_err(|e| {
-            //     log::error!("Failed to serialize events: {:?}", e);
-            //     <Error<T>>::JsonSerializationError
-            // })?;
-
-            // Ok(events_json.into_bytes())
-            fn create_empty_json() -> Vec<u8> {
-                let empty_json = serde_json::json!({
-                    "events": [[{
-                        "id": 1,
-                        "data": [],
-                        "timestamp": 0,
-                        "block_height": 0,
-                        "last_epoch": 0,
-                        "last_blockhash": [],
-                        "last_slot": 0,
-                        "new_epoch": 0,
-                        "new_slot": 0,
-                        "new_blockhash": [],
-                        "epoch_nonce": [],
-                        "extra_entropy": null
-                    }]], // Note the nested array to match Vec<Vec<CustomEvent>>
-                    "success": true
-                });
-                serde_json::to_vec(&empty_json).unwrap_or_default()
-            }
-            fn create_json_with_event() -> Vec<u8> {
-                let event_json = serde_json::json!({
-                    "events": [{
-                        "id": 1,
-                        "data": {
-                            "type": "EpochChange",
-                            "data": {
-                                "last_epoch": 574,
-                                "last_blockhash": "de3ea4083d96987a9a3d2f1df14a009fdb548f7063a40fb707d2b87ca471cc5d",
-                                "last_slot": 49679976,
-                                "new_epoch": 575,
-                                "new_slot": 49680007,
-                                "new_blockhash": "18f9fe3cce213d40f8f16e16e73dad7dd28cf394d7e25c720cc83324ca8fa560",
-                                "epoch_nonce": "8972981c2fa11e815ab0b89e7c1e1603fe30b2c4d4eb6becaf109bf2fd912a22",
-                                "extra_entropy": null
-                            }
-                        },
-                        "timestamp": 1620000000,
-                        "block_height": 100,
-                        "last_epoch": 574,
-                        "last_blockhash": "de3ea4083d96987a9a3d2f1df14a009fdb548f7063a40fb707d2b87ca471cc5d",
-                        "last_slot": 49679976,
-                        "new_epoch": 575,
-                        "new_slot": 49680007,
-                        "new_blockhash": "18f9fe3cce213d40f8f16e16e73dad7dd28cf394d7e25c720cc83324ca8fa560",
-                        "epoch_nonce": "8972981c2fa11e815ab0b89e7c1e1603fe30b2c4d4eb6becaf109bf2fd912a22",
-                        "extra_entropy": null
-                    }],
-                    "success": true
-                });
-
-                serde_json::to_vec(&event_json).unwrap_or_default()
-            }
-
-            // let empty_json = create_empty_json();
-            let empty_json = Self::process_real_event()?;
-            Ok(empty_json)
-        }
-    }
-
     impl<T: Config> Pallet<T>
     where
         <T as pallet::Config>::ValidatorId:
@@ -665,58 +413,68 @@ pub mod pallet {
 
             // Process each event
             let mut processed_events = Vec::new();
-    for (i, event_group) in events.iter().enumerate() {
-        let mut processed_group = Vec::new();
-        for (j, event) in event_group.as_array().ok_or_else(|| {
-            log::error!("Event group {} is not an array", i);
-            <Error<T>>::InvalidResponseFormat
-        })?.iter().enumerate() {
-            log::info!("Processing event {}.{}: {:?}", i, j, event);
-
-            // Check if the event is a JSON object
-            if let Some(event_obj) = event.as_object() {
-                let id = event_obj["id"].as_u64().ok_or_else(|| {
-                    log::error!("Failed to extract id from event {}.{}", i, j);
-                    <Error<T>>::InvalidResponseFormat
-                })?;
-                let timestamp = event_obj["timestamp"].as_u64().ok_or_else(|| {
-                    log::error!("Failed to extract timestamp from event {}.{}", i, j);
-                    <Error<T>>::InvalidResponseFormat
-                })?;
-                let block_height = event_obj["block_height"].as_u64().ok_or_else(|| {
-                    log::error!("Failed to extract block_height from event {}.{}", i, j);
-                    <Error<T>>::InvalidResponseFormat
-                })?;
-                
-                // Parse the data field, which is a stringified JSON
-                let data_str = event_obj["data"].as_str().ok_or_else(|| {
-                    log::error!("Failed to extract data string from event {}.{}", i, j);
-                    <Error<T>>::InvalidResponseFormat
-                })?;
-
-                log::info!("Data string for event {}.{}: {}", i, j, data_str);
-
-                let data: CustomData = serde_json::from_str(data_str).map_err(|e| {
-                    log::error!("Failed to parse event data for event {}.{}: {:?}", i, j, e);
-                    <Error<T>>::JsonSerializationError
-                })?;
-
-                let custom_event = CustomEvent {
-                    id,
-                    data,
-                    timestamp,
-                    block_height,
-                };
-
-                log::info!("Processed event {}.{}: {:?}", i, j, custom_event);
-
-                processed_group.push(custom_event);
-            } else {
-                log::warn!("Skipping non-object event {}.{}: {:?}", i, j, event);
+            for (i, event_group) in events.iter().enumerate() {
+                let mut processed_group = Vec::new();
+                for (j, event) in event_group
+                    .as_array()
+                    .ok_or_else(|| {
+                        log::error!("Event group {} is not an array", i);
+                        <Error<T>>::InvalidResponseFormat
+                    })?
+                    .iter()
+                    .enumerate()
+                {
+                    log::info!("Processing event {}.{}: {:?}", i, j, event);
+
+                    // Check if the event is a JSON object
+                    if let Some(event_obj) = event.as_object() {
+                        let id = event_obj["id"].as_u64().ok_or_else(|| {
+                            log::error!("Failed to extract id from event {}.{}", i, j);
+                            <Error<T>>::InvalidResponseFormat
+                        })?;
+                        let timestamp = event_obj["timestamp"].as_u64().ok_or_else(|| {
+                            log::error!("Failed to extract timestamp from event {}.{}", i, j);
+                            <Error<T>>::InvalidResponseFormat
+                        })?;
+                        let block_height = event_obj["block_height"].as_u64().ok_or_else(|| {
+                            log::error!("Failed to extract block_height from event {}.{}", i, j);
+                            <Error<T>>::InvalidResponseFormat
+                        })?;
+
+                        // Parse the data field, which is a stringified JSON
+                        let data_str = event_obj["data"].as_str().ok_or_else(|| {
+                            log::error!("Failed to extract data string from event {}.{}", i, j);
+                            <Error<T>>::InvalidResponseFormat
+                        })?;
+
+                        log::info!("Data string for event {}.{}: {}", i, j, data_str);
+
+                        let data: CustomData = serde_json::from_str(data_str).map_err(|e| {
+                            log::error!(
+                                "Failed to parse event data for event {}.{}: {:?}",
+                                i,
+                                j,
+                                e
+                            );
+                            <Error<T>>::JsonSerializationError
+                        })?;
+
+                        let custom_event = CustomEvent {
+                            id,
+                            data,
+                            timestamp,
+                            block_height,
+                        };
+
+                        log::info!("Processed event {}.{}: {:?}", i, j, custom_event);
+
+                        processed_group.push(custom_event);
+                    } else {
+                        log::warn!("Skipping non-object event {}.{}: {:?}", i, j, event);
+                    }
+                }
+                processed_events.push(processed_group);
             }
-        }
-        processed_events.push(processed_group);
-    }
 
             // Serialize the processed events back to JSON
             let events_json = serde_json::to_string(&processed_events).map_err(|e| {
@@ -827,86 +585,6 @@ pub mod pallet {
             Ok(())
         }
 
-        // fn fetch_and_process_events_from_queue() -> Result<(), Error<T>> {
-        //     log::info!("Fetching all events from the queue");
-
-        //     // Fetch all events
-        //     let response = Self::fetch_all_events()?;
-        //     let bounded_body: BoundedVec<u8, MaxDataLength> = BoundedVec::try_from(response).map_err(|_| {
-        //         log::error!("Failed to convert to BoundedVec");
-        //         <Error<T>>::HttpFetchingError
-        //     })?;
-
-        //     // Deserialize the events
-        //     let events: Vec<CustomEvent> = serde_json::from_slice(&bounded_body).map_err(|e| {
-        //         log::error!("Failed to deserialize events: {:?}", e);
-        //         <Error<T>>::JsonSerializationError
-        //     })?;
-
-        //     // Process all events if node is the leader
-        //     if Self::is_leader() {
-        //         log::info!("Node is the leader, processing events");
-
-        //         let mut events_to_remove: BoundedVec<u64, MaxRemoveEventsLength> =
-        //             BoundedVec::default();
-
-        //         for event in bounded_events.iter() {
-        //             log::info!("Validating and processing event: {:?}", event);
-
-        //             // Validate and process the event
-        //             Self::validate_and_process_event(event.clone())?;
-
-        //             // Encode the event payload
-        //             let payload = event.encode();
-
-        //             // Submit the encoded payload as an unsigned transaction
-        //             log::info!(
-        //                 "Submitting unsigned transaction with payload: {:?}",
-        //                 payload
-        //             );
-
-        //             // Decode the payload to create a call
-        //             let call = match Call::<T>::decode(&mut &payload[..]) {
-        //                 Ok(call) => call,
-        //                 Err(_) => {
-        //                     log::error!("Failed to decode the provided transaction payload");
-        //                     continue;
-        //                 }
-        //             };
-
-        //             // Submit the transaction
-        //             match frame_system::offchain::SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(
-        //                 call.into(),
-        //             ) {
-        //                 Ok(_) => {
-        //                     // If submission is successful, mark event for removal
-        //                     log::info!(
-        //                         "Transaction submitted successfully, marking event for removal: {:?}",
-        //                         event.id
-        //                     );
-        //                     events_to_remove
-        //                         .try_push(event.id)
-        //                         .map_err(|_| <Error<T>>::StorageOverflow)?;
-        //                 },
-        //                 Err(e) => {
-        //                     log::error!("Error submitting unsigned transaction: {:?}", e);
-        //                 }
-        //             }
-        //         }
-
-        //         // Remove processed events from the storage
-        //         for event_id in events_to_remove {
-        //             log::info!(
-        //                 "Removing processed event from priority queue: {:?}",
-        //                 event_id
-        //             );
-        //             Self::remove_event_from_priority_queue(event_id)?;
-        //         }
-        //     }
-
-        //     Ok(())
-        // }
-
         fn remove_event_from_priority_queue(event_id: u64) -> Result<(), Error<T>> {
             // Call the HTTP method to remove the event from the priority queue
             let remove_event_payload = serde_json::json!({
@@ -963,6 +641,31 @@ pub mod pallet {
         fn get_event(event_id: u64) -> Option<CustomEvent> {
             Some(EventStorage::<T>::get(event_id))
         }
+        // Use structured logging for better clarity in logs.
+        fn log_event_processing(event: &CustomEvent) {
+            log::info!(
+                target: "event_processing",
+                "Processing event: id={}, timestamp={}, block_height={}",
+                event.id, event.timestamp, event.block_height
+            );
+        }
+
+        
+    }
+    
+
+    // Add more descriptive error messages to help with debugging.
+    impl<T: Config> Pallet<T> {
+        fn error_description(error: &Error<T>) -> &'static str {
+            match error {
+                Error::HttpFetchingError => "HTTP request failed",
+                Error::InvalidUtf8 => "UTF-8 conversion error",
+                Error::InvalidResponseFormat => "Response format is incorrect",
+                Error::JsonSerializationError => "Error serializing or deserializing JSON",
+                Error::InvalidEventData => "Event data validation failed",
+                _ => "Unknown error",
+            }
+        }
     }
 
     #[derive(Deserialize, Debug)]
@@ -1001,6 +704,9 @@ pub mod pallet {
         }
     }
 
+    
+
+
     #[pallet::call]
     impl<T: Config> Pallet<T> {
         #[pallet::call_index(0)]
diff --git a/pallets/substrate-validator-set/src/mock.rs b/pallets/substrate-validator-set/src/mock.rs
index 3c1893e..8fc2282 100644
--- a/pallets/substrate-validator-set/src/mock.rs
+++ b/pallets/substrate-validator-set/src/mock.rs
@@ -81,8 +81,8 @@ pub struct TestShouldEndSession;
 impl ShouldEndSession<u64> for TestShouldEndSession {
 	fn should_end_session(now: u64) -> bool {
 		let l = SessionLength::get();
-		now % l == 0 ||
-			ForceSessionEnd::mutate(|l| {
+		now % l == 0
+			|| ForceSessionEnd::mutate(|l| {
 				let r = *l;
 				*l = false;
 				r
